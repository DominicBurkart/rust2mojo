//! Mojo code generation from intermediate AST
//!
//! This module handles generating Mojo source code from our intermediate AST representation.

use crate::ast::*;
use crate::error::Result;

/// Generate Mojo code from the intermediate AST
pub fn generate_mojo(compilation_unit: &CompilationUnit) -> Result<String> {
    let mut generator = MojoGenerator::new();
    generator.generate_compilation_unit(compilation_unit)
}

struct MojoGenerator {
    output: String,
    indent_level: usize,
}

impl MojoGenerator {
    fn new() -> Self {
        Self {
            output: String::new(),
            indent_level: 0,
        }
    }

    fn generate_compilation_unit(&mut self, unit: &CompilationUnit) -> Result<String> {
        // Add header comment
        self.writeln("# Generated Mojo code from Rust source");
        self.writeln("# This file was automatically generated by rust2mojo");
        self.writeln("");

        // Generate imports for common Mojo modules
        self.writeln("from memory import UnsafePointer");
        self.writeln("from collections import List");
        self.writeln("");

        // Generate each item
        for item in &unit.items {
            self.generate_item(item)?;
            self.writeln("");
        }

        Ok(self.output.clone())
    }

    fn generate_item(&mut self, item: &Item) -> Result<()> {
        match item {
            Item::Function(func) => self.generate_function(func),
            Item::Struct(struct_item) => self.generate_struct(struct_item),
            Item::Enum(enum_item) => self.generate_enum(enum_item),
            Item::Impl(impl_item) => self.generate_impl(impl_item),
            Item::Use(use_item) => self.generate_use(use_item),
            Item::Mod(mod_item) => self.generate_module(mod_item),
            Item::Const(const_item) => self.generate_const(const_item),
            Item::Static(static_item) => self.generate_static(static_item),
            Item::Type(type_item) => self.generate_type_alias(type_item),
        }
    }

    fn generate_function(&mut self, func: &Function) -> Result<()> {
        // Generate function signature
        let visibility = self.mojo_visibility(&func.visibility);
        let name = &func.name;

        // Convert main function to special Mojo main
        if name == "main" {
            self.writeln("fn main():");
        } else {
            self.write(&format!("{}fn {}(", visibility, name));

            // Generate parameters
            for (i, param) in func.parameters.iter().enumerate() {
                if i > 0 {
                    self.write(", ");
                }
                self.write(&format!("{}: {}", param.name, self.mojo_type(&param.type_)));
            }

            self.write(")");

            // Generate return type
            if let Some(return_type) = &func.return_type {
                self.write(&format!(" -> {}", self.mojo_type(return_type)));
            }

            self.writeln(":");
        }

        // Generate function body
        self.indent();
        if func.body.is_empty() {
            self.writeln("pass");
        } else {
            for stmt in &func.body {
                self.generate_statement(stmt)?;
            }
        }
        self.dedent();

        Ok(())
    }

    fn generate_struct(&mut self, struct_item: &Struct) -> Result<()> {
        let visibility = self.mojo_visibility(&struct_item.visibility);
        self.writeln(&format!("{}struct {}:", visibility, struct_item.name));

        self.indent();
        if struct_item.fields.is_empty() {
            self.writeln("pass");
        } else {
            for field in &struct_item.fields {
                self.writeln(&format!(
                    "var {}: {}",
                    field.name,
                    self.mojo_type(&field.type_)
                ));
            }

            // Generate constructor
            self.writeln("");
            self.write("fn __init__(inout self");
            for field in &struct_item.fields {
                self.write(&format!(
                    ", {}: {}",
                    field.name,
                    self.mojo_type(&field.type_)
                ));
            }
            self.writeln("):");

            self.indent();
            for field in &struct_item.fields {
                self.writeln(&format!("self.{} = {}", field.name, field.name));
            }
            self.dedent();
        }
        self.dedent();

        Ok(())
    }

    fn generate_enum(&mut self, _enum_item: &Enum) -> Result<()> {
        // Mojo doesn't have direct enum support, generate as struct with static methods
        self.writeln("# TODO: Enum conversion not yet implemented");
        Ok(())
    }

    fn generate_impl(&mut self, _impl_item: &Impl) -> Result<()> {
        // Mojo impl blocks are part of struct definitions
        self.writeln("# TODO: Impl block conversion not yet implemented");
        Ok(())
    }

    fn generate_use(&mut self, use_item: &Use) -> Result<()> {
        // Convert Rust use statements to Mojo imports
        self.writeln(&format!("# Rust use: {}", use_item.path));
        Ok(())
    }

    fn generate_module(&mut self, _mod_item: &Module) -> Result<()> {
        self.writeln("# TODO: Module conversion not yet implemented");
        Ok(())
    }

    fn generate_const(&mut self, const_item: &Const) -> Result<()> {
        let visibility = self.mojo_visibility(&const_item.visibility);
        self.writeln(&format!(
            "{}alias {} = {}",
            visibility,
            const_item.name,
            self.mojo_expression(&const_item.value)
        ));
        Ok(())
    }

    fn generate_static(&mut self, static_item: &Static) -> Result<()> {
        let visibility = self.mojo_visibility(&static_item.visibility);
        let mutability = if static_item.mutable { "var" } else { "alias" };
        self.writeln(&format!(
            "{}{} {} = {}",
            visibility,
            mutability,
            static_item.name,
            self.mojo_expression(&static_item.value)
        ));
        Ok(())
    }

    fn generate_type_alias(&mut self, type_item: &TypeAlias) -> Result<()> {
        let visibility = self.mojo_visibility(&type_item.visibility);
        self.writeln(&format!(
            "{}alias {} = {}",
            visibility,
            type_item.name,
            self.mojo_type(&type_item.type_)
        ));
        Ok(())
    }

    fn generate_statement(&mut self, stmt: &Statement) -> Result<()> {
        match stmt {
            Statement::Expression(expr) => {
                self.writeln(&self.mojo_expression(expr));
            }
            Statement::Let {
                name,
                mutable,
                type_,
                value,
            } => {
                let keyword = if *mutable { "var" } else { "let" };
                let type_annotation = if let Some(ty) = type_ {
                    format!(": {}", self.mojo_type(ty))
                } else {
                    String::new()
                };
                let assignment = if let Some(val) = value {
                    format!(" = {}", self.mojo_expression(val))
                } else {
                    String::new()
                };
                self.writeln(&format!(
                    "{} {}{}{}",
                    keyword, name, type_annotation, assignment
                ));
            }
            Statement::Return(expr) => {
                if let Some(e) = expr {
                    self.writeln(&format!("return {}", self.mojo_expression(e)));
                } else {
                    self.writeln("return");
                }
            }
            Statement::If {
                condition,
                then_branch,
                else_branch,
            } => {
                self.writeln(&format!("if {}:", self.mojo_expression(condition)));
                self.indent();
                for stmt in then_branch {
                    self.generate_statement(stmt)?;
                }
                self.dedent();

                if let Some(else_stmts) = else_branch {
                    self.writeln("else:");
                    self.indent();
                    for stmt in else_stmts {
                        self.generate_statement(stmt)?;
                    }
                    self.dedent();
                }
            }
            Statement::While { condition, body } => {
                self.writeln(&format!("while {}:", self.mojo_expression(condition)));
                self.indent();
                for stmt in body {
                    self.generate_statement(stmt)?;
                }
                self.dedent();
            }
            Statement::For {
                pattern,
                iterator,
                body,
            } => {
                self.writeln(&format!(
                    "for {} in {}:",
                    pattern,
                    self.mojo_expression(iterator)
                ));
                self.indent();
                for stmt in body {
                    self.generate_statement(stmt)?;
                }
                self.dedent();
            }
            Statement::Block(stmts) => {
                for stmt in stmts {
                    self.generate_statement(stmt)?;
                }
            }
            _ => {
                self.writeln("# TODO: Statement conversion not yet implemented");
            }
        }
        Ok(())
    }

    fn mojo_expression(&self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(lit) => self.mojo_literal(lit),
            Expression::Identifier(name) => name.clone(),
            Expression::Path(path) => path.clone(),
            Expression::Call { function, args } => {
                let func_str = self.mojo_expression(function);
                let args_str = args
                    .iter()
                    .map(|arg| self.mojo_expression(arg))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("{}({})", func_str, args_str)
            }
            Expression::Binary { left, op, right } => {
                format!(
                    "{} {} {}",
                    self.mojo_expression(left),
                    self.mojo_binary_op(op),
                    self.mojo_expression(right)
                )
            }
            _ => "# TODO: Expression conversion".to_string(),
        }
    }

    fn mojo_literal(&self, lit: &Literal) -> String {
        match lit {
            Literal::String(s) => format!("\"{}\"", s),
            Literal::Integer(i) => i.to_string(),
            Literal::Float(f) => f.to_string(),
            Literal::Boolean(b) => {
                if *b {
                    "True".to_string()
                } else {
                    "False".to_string()
                }
            }
            Literal::Char(c) => format!("\"{}\"", c),
        }
    }

    fn mojo_binary_op(&self, op: &BinaryOp) -> &'static str {
        match op {
            BinaryOp::Add => "+",
            BinaryOp::Sub => "-",
            BinaryOp::Mul => "*",
            BinaryOp::Div => "/",
            BinaryOp::Mod => "%",
            BinaryOp::Eq => "==",
            BinaryOp::Ne => "!=",
            BinaryOp::Lt => "<",
            BinaryOp::Le => "<=",
            BinaryOp::Gt => ">",
            BinaryOp::Ge => ">=",
            BinaryOp::And => "and",
            BinaryOp::Or => "or",
            BinaryOp::BitAnd => "&",
            BinaryOp::BitOr => "|",
            BinaryOp::BitXor => "^",
            BinaryOp::Shl => "<<",
            BinaryOp::Shr => ">>",
            BinaryOp::Assign => "=",
        }
    }

    #[allow(clippy::only_used_in_recursion)]
    fn mojo_type(&self, ty: &Type) -> String {
        match ty {
            Type::Path(path) => {
                // Map common Rust types to Mojo types
                match path.as_str() {
                    "i32" => "Int32".to_string(),
                    "i64" => "Int64".to_string(),
                    "u32" => "UInt32".to_string(),
                    "u64" => "UInt64".to_string(),
                    "f32" => "Float32".to_string(),
                    "f64" => "Float64".to_string(),
                    "bool" => "Bool".to_string(),
                    "String" => "String".to_string(),
                    "str" => "StringRef".to_string(),
                    _ => path.clone(),
                }
            }
            Type::Reference { inner, .. } => {
                // Mojo doesn't have explicit references, use the inner type
                self.mojo_type(inner)
            }
            Type::Array { inner, size } => {
                if let Some(s) = size {
                    format!("StaticTuple[{}, {}]", self.mojo_type(inner), s)
                } else {
                    format!("List[{}]", self.mojo_type(inner))
                }
            }
            Type::Slice(inner) => {
                format!("List[{}]", self.mojo_type(inner))
            }
            Type::Tuple(types) => {
                let type_strs = types.iter().map(|t| self.mojo_type(t)).collect::<Vec<_>>();
                format!("Tuple[{}]", type_strs.join(", "))
            }
            Type::Unit => "NoneType".to_string(),
            _ => "# TODO: Type conversion".to_string(),
        }
    }

    fn mojo_visibility(&self, vis: &Visibility) -> &'static str {
        match vis {
            Visibility::Public => "", // Mojo defaults to public
            _ => "",                  // Mojo doesn't have explicit private visibility
        }
    }

    fn write(&mut self, text: &str) {
        self.output.push_str(text);
    }

    fn writeln(&mut self, text: &str) {
        let indent = "    ".repeat(self.indent_level);
        self.output.push_str(&format!("{}{}\n", indent, text));
    }

    fn indent(&mut self) {
        self.indent_level += 1;
    }

    fn dedent(&mut self) {
        if self.indent_level > 0 {
            self.indent_level -= 1;
        }
    }
}
